@gmf
@"http://www.eclipse.org/OCL/Import"(ecore="http://www.eclipse.org/emf/2002/Ecore")
@Ecore(invocationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", settingDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot", validationDelegates="http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot")
@namespace(uri="http://demobuilder.agreement.metamodel", prefix="mmag")
package AgreementMetamodel;

@gmf.diagram
class AgreementCompositor {

  @gmf.compartment
  val AgreementModel[*] agreements;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Agreement", tool.description="Creates a new agreement")
@Ecore(constraints="metricProperty")
@"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(metricProperty="
			self._context.metrics -> includesAll(self.agTerm.monitorableProperties.metric -> 
				union(self.agTerm.serviceConfigurarion.configurationProperties.metric))")
class AgreementModel {
  attr String ~id;
  attr double version;

  @gmf.compartment
  val Context[1] context;

  @gmf.compartment
  val AgreementTerm[1] agTerm;
}

@gmf.node(label.placement="none", label.icon="false", figure="rectangle", tool.name="Context", tool.description="Creates a new context section")
@Ecore(constraints="providerAndConsumer")
@"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(providerAndConsumer="let hasProvider : Boolean = actors
			->exists(a : Actor | a.role = Role::PROVIDER)
		in
		let hasConsumer : Boolean = actors
			->exists(a : Actor | a.role = Role::CONSUMER)
		in actors
			->size() < 3 and (actors
			->size() = 1 implies hasProvider) and (actors
			->size() = 2 implies hasProvider and hasConsumer)")
class Context {

  @gmf.compartment
  val Actor[1..2] actors;

  @gmf.compartment
  val Metric[*] metrics;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Actor", tool.description="Creates a new actor")
class Actor {
  attr String ~id;
  attr Role role = "PROVIDER";
  attr RoleType roleType = "RESPONDER";
}

enum Role {
  PROVIDER = 0;
  CONSUMER = 1;
}

enum RoleType {
  INITIATOR = 0;
  RESPONDER = 1;
}

enum Datatype {
  INTEGER = 0;
  FLOAT = 1;
  NATURAL = 2;
  NUMBER = 3;
  BOOLEAN = 4;
  SET = 5;
  ENUM = 6;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Metric", tool.description="Creates a new metric")
class Metric {
  attr Datatype type = "INTEGER";
  attr String ~id;

  @gmf.compartment
  val Domain domain;
}

abstract class Domain {
}

@gmf.node(label="min,max", label.pattern="[{0}..{1}]", label.icon="false", figure="rectangle", tool.name="Range", tool.description="Creates a range domain")
class Range extends Domain {
  attr Integer min = "1";
  attr Integer max = "100";
}

@gmf.node(label.placement="none", label.icon="false", figure="rectangle", tool.name="Enumerated", tool.description="Creates an enumerated domain")
class Enumerated extends Domain {

  @gmf.compartment
  val Value[*] values;
}

@gmf.node(label.placement="none", label.icon="false", figure="rectangle", tool.name="Agreement Term", tool.description="Creates an agreement terms section")
class AgreementTerm {

  @gmf.compartment
  val ServiceConfiguration[1] serviceConfigurarion;

  @gmf.compartment
  val MonitorableProperty[*] monitorableProperties;

  @gmf.compartment
  val GuaranteeTerm[*] guaranteeTerms;
}

@gmf.node(label="serviceName", label.icon="false", figure="rectangle", tool.name="Service Configuration", tool.description="Creates a service configuration section")
class ServiceConfiguration {
  attr String endpointReference;
  attr String definitionReference;
  attr String monitorReference;
  attr String serviceName;

  @gmf.compartment
  val Feature[*] features;

  @gmf.compartment
  val ConfigurationProperty[*] configurationProperties;
}

@gmf.node(label="id,role", label.pattern="{0} - {1}", label.icon="false", figure="rectangle", tool.name="Guarantee Term", tool.description="Creates a new guarantee term")
class GuaranteeTerm {
  attr String ~id;
  attr Role role = "PROVIDER";

  @gmf.compartment
  val SLO[1] slo;

  @gmf.compartment
  val QualifyingCondition qualifyingCondition;

  @gmf.compartment
  val Compensation[*] compensations;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Feature", tool.description="Creates a new feature")
class Feature {
  attr String ~id;

  @gmf.compartment
  val Parameter[*] parameters;
}

@Ecore(constraints="idNotEmpty metricProperty")
@"http://www.eclipse.org/emf/2002/Ecore/OCL/Pivot"(idNotEmpty="id
			->notEmpty()", metricProperty="metric
			->notEmpty()")
abstract class Property {
  attr String expression;
  attr Scope scope = "GLOBAL";
  attr String definitionReference;
  attr String ~id;

  @gmf.link
  ref Feature features;

  @gmf.link
  ref Metric metric;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Configuration Property", tool.description="Creates a new configuration property")
class ConfigurationProperty extends Property {
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Monitorable Property", tool.description="Creates a new monitorable property")
class MonitorableProperty extends Property {
  attr String monitorReference;
}

@gmf.node(label="expression", label.icon="false", figure="rectangle", tool.name="SLO", tool.description="Creates a new service level objective")
class SLO {
  attr String expression;
}

enum Scope {
  GLOBAL = 0;
  LOCAL = 1;
}

@gmf.node(label="interval,type", label.pattern="with {0} {1}", label.icon="false", figure="rectangle", tool.name="Compensation", tool.description="Creates a new compensation")
class Compensation {
  attr AssessmentInterval interval = "MONTHLY";
  attr CompensationType type = "REWARD";

  @gmf.compartment
  val CompensationElement[*] compensationElements;
}

@gmf.node(label="expression", label.pattern="onlyIf({0})", label.icon="false", figure="rectangle", tool.name="Qualifying Condition", tool.description="Creates a new qualifying condition")
class QualifyingCondition {
  attr String expression;
}

@gmf.node(label="expression,condition", label.pattern="of {1} if {0}", label.icon="false", figure="rectangle", tool.name="Compensation Element", tool.description="Creates a new compensation element")
class CompensationElement {
  attr String expression;
  attr String condition;
}

enum AssessmentInterval {
  YEARLY = 0;
  MONTHLY = 1;
  WEEKLY = 2;
  DAILY = 3;
  HOURLY = 4;
}

enum CompensationType {
  PENALTY = 0;
  REWARD = 1;
}

@gmf.node(label="name", label.icon="false", figure="rectangle", tool.name="Parameter", tool.description="Creates a new parameter")
class Parameter {
  attr String name;
}

@gmf.node(label="id", label.icon="false", figure="rectangle", tool.name="Value", tool.description="Creates a new value")
class Value {
  attr String ~id;
}

